---
title: 深入浅出Node
---
### Node简介
1. Node的结构与Chrome十分相似，它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件驱动来服务IO。
2. Node的特点
- 异步I/O
- 事件与回调函数（事件的编程方式具有轻量级、松耦合、只关注事务点等有事，但是多个异步任务的场景下事件与事件相互独立，如何协作是一个问题。）
- 单线程（单线程不用在意状态的同步问题，没有死锁，也没有上下文切换带来的性能开销，但是也有无法利用多核CPU、错误会导致整个应用退出、大量计算占用CPU导致无法继续调用异步I/O。Node通过child_process子进程讲计算来利用多核CPU）
- 跨平台（基于libuv实现了跨平台）
3. Node的应用场景
- I/O密集型（面向网络且擅长并行I/O，优势在于Node利用事件循环的处理能力，而不是为每一个请求启动一个线程）。
- 是否不擅长CPU密集型任务（如果有长时间运行的计算会导致CPU时间片不能释放，后续I/O无法发起。但是只要适当调整和分解大型运算任务为多个小任务，使运算可以适时释放，不阻塞I/O调用发起）
4. Node的使用者的倚重点
- 前后端编程语言环境统一
- Node带来的高性能I/O用于实时应用
- 并行I/O使得使用者可以更高效利用分布式环境
- 并行I/O有效利用稳定借口提升Web渲染能力
- 云计算平台提供Node支持
- 工具类应用

### 模块机制
#### CommonJS规范
CommonJS规范的提出，主要为了弥补当前JS没有标准的缺陷，达到具备开发大型应用的基础能力。
模块规范
- 模块引用
```javascript
var math = require('math');
```
- 模块定义
上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，代表模块自身，exports是module的属性。
- 模块标识
模块标识就是传递给require()方法的参数，必须符合小拖放命名的字符串，或者相对路径or绝对路径。
### Node的模块实现
1. Node中引入模块，需要路径分析、文件定位、编译执行三个步骤。
2. Node中模块分为两类，一类是Node提供的模块称为核心模块。另一类是用户编写的模块，称为文件模块。
    - 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，这部分核心模块被直接加载进内存，就可以省略文件定位和编译执行步骤，路径分析中优先判断
    - 文件模块在运行时动态加载，需要三个步骤，会慢一些
3. Node对引入过的模块都会进行缓存，缓存的是编译和执行之后的对象。无论核心模块还是文件模块，都是优先采用缓存。核心模块的缓存检查先于文件模块的缓存检查。
4. 路径分析和文件定位
###### 模块标识符分析：
 - 模块加载速度：缓存模块<核心模块<路径形式的文件模块<自定义模块
###### 文件定位分析：
 - 文件扩展名分析，Node会按照.js .json .node的次序补足扩展名，依次尝试。尝试过程中，需要调用fs模块同步阻塞式地判断文件是否存在。
 - 目录分析和包：分析标识符查找到一个目录，Node会当成一个包来处理。会去查找包里面是否有package.json，取出main属性指定的文件来定位。
如果main属性指定文件名错误，会将index当做默认文件名。如果这一级目录还没有找到，会下一个模块路径进行遍历。如果所有模块路径都找不到，就跑出查找失败的异常。
###### 模块编译：
编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，根据路径载入并编译。
不同文件名载入方法有所不同
  - .js 通过fs模块同步读取文件后编译执行。
  - .node C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件
  - .json 通过fs模块同步读取文件后，用JSON.parse()解析返回结果
  - 其余扩展名，被当做js文件载入
每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能
##### JS模块的编译
在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。
```javascript
(function (exports, require, module, _filename, _dirname) { // 新增行
  var math = require('math');
  exports.area = function (radius) {
    return Math.PI * radius * radius;
  };
}); // 新增行
```
通过新增了头和尾，进行了作用域隔离，包装之后的代码会通过vm原生模块的runInThisContext()方法执行，返回一个具体的function对象。
最后把当前模块对象的exports属性、require()方法、module及在文件定位中得到的完整的文件路径和文件目录作为参数传入function()执行。
执行之后，模块的exports属性被返回给了调用方。
exports对象是通过形参的方式传入的，直接复制会改变形参的引用，但不会改变作用域外的值，因此需要用module.exports迂回一下。
##### C/C++模块的编译
Node调用process.dlopen()方法进行加载和执行。dlopen()方法在不同平台不同实现，通过libuv兼容层进行了封装。
实际上node的模块文件并不需要编译，因为已经是编译生成的，所以只有加载和执行的过程。
在执行的过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。
C/C++模块执行效率快，但是入门门槛高。
##### JSON文件的编译
利用fs模块同步读取JSON文件的内容之后，调用JSON.parse()方法得到对象，在赋给模块对象的exports，供外部调用。




