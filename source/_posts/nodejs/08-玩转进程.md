---
title: 玩转进程
date: 2022-01-09 19:07:00
tags: 
  - 进程
categories: Node
---
### 1. Node单进程的优缺点
JS是会运行在单个进程的单个线程上。
优点：程序状态单一、没有多线程的情况下没有锁、线程同步的问题、操作系统调度时很少上下文切换，因此CPU利用率较高
缺点：CPU和服务器都是多核导致利用率不高，单进程一旦抛出的异常没有被捕获，就会导致整个进程的崩溃
PS：实际上Node自身也有一定的IO线程存在，这些I/O线程由底层libuv完成，对Node开发者是透明的。
### 2. 事件驱动
由于所有处理都在单线程上进行，影响事件驱动服务模型性能的点在于CPU的计算能力。
### 3. 创建子进程
Node提供了child_process模块，并且也提供了child_process.fork()函数实现进程的复制。
child_process让Node可以随意创建子进程，它提供了四个方法，分别是：
```javascript
spawn() // 启动一个子进程来执行命令
exec()  // 启动一个子进程来执行命令，但是接口不同，有一个回调函数获取子进程的状况
execFile() // 启动子进程来执行可执行文件
fork()  // 与spwan()类似，但是创建Node的子进程只需要指定要执行的JS文件模块
```
### 4. 进程间通信
- IPC：Inter-Process Communication，进程间通行的目的是为了让不同的进程能够互相访问资源并进行协调工作
- 实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。
- Node中实现IPC通道的是管道，但是这管道只是个抽象层面的称呼，具体细节实现由libuv提供，在windows下由命名管道，linux下通过Unix Domain Socket实现。表现就是应用层上的进程间通信只有简单的message事件和send()方法
- 父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通过环境变量高速紫禁城这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接。
- Node在0.5.9引入了进程间发送句柄的功能，send()方法除了能通过IPC发送数据外，还能发送句柄。句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。例如可以标识一个服务器端socket对象、一个客户端socket对象、一个UDP套接字、一个管道等。
- 子进程对象send()方法可以发送的句柄类型包括：net.Socket、net.Server、net.Native、dgram.Socket、dgram.Native
- Node进程之间只有消息能传递，不会真正传递对象，这种错觉是抽象封装的结果
- 独立启动的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听同一个端口时会抛异常。子进程之间端口共同监听，是因为send()发送的句柄文件描述符是一样的，监听同一个端口就不会引发异常。
- 多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用，因此是抢占式的。

### 5. 集群稳定之路
- 父进程可以监听到的子进程的事件，包括：error、exit、close、disconnect。除了send()方法之外，还可以通过kill()方法给子进程发送消息，kill并不是直接通过IPC将子进程杀死，是给子进程一个系统信号，收到信号后子进程退出。
- 子进程的自动重启，可以通过监听子进程的exit去做，但是会出现全部子进程都在等待退出，导致新来的请求无法进行处理
- 可以通过自杀信号的方式，提前通知父进程，然后父进程就去创建新的进程，让创建新工作进程在前，退出异常进程在后，完成进行的平滑重启。对于一些断开连接后再重启的场景，如果断开连接时间较长，可能需要设置超时机制。
- 限量重启：可以通过设置一段时间内的最大重启次数进行判断，当到达最大重启次数时，giveup。但是giveup是一个非常严重的异常事件，此时集群中没有任何进程服务，十分危险。
- Node中默认提供的机制是操作系统的抢占式策略。
- 在进程中判断是主进程还是工作进程，主要取决于环境变量中是否有NODE_UNIQUE_ID

