---
title: 异步IO
date: 2021-03-09 17:25:30
tags: 
  - 异步IO
categories: Node
---
### 1. 异步IO原因
1. 提升用户体验，如果加载资源需要阻塞渲染等事件，对用户不够友好。
2. 资源分配：利用单线程，远离多线程的死锁和状态同步等问题；再利用异步I/O，让单线程远离阻塞，更好使用CPU。

 
### 2. 异步I/O现状
#### 2.1. 异步I/O与非阻塞I/O
阻塞I/O与非阻塞I/O：操作系统对I/O只有阻塞与非阻塞两种方式。阻塞I/O被调用时，需要等待I/O完全执行完成才会返回结果。这样会导致CPU的等待，处理能力没有被充分利用。
非阻塞I/O是立即返回，但是对于抽象出来的文件而言，并没有返回文件的内容，只有文件描述符。非阻塞I/O返回的并不是业务层需要的数据，而是当前调用的状态，为了获取完整数据，需要重复调用I/O来确认是否完成，这种重复判断操作是否完成的技术叫轮询。
阻塞I/O会浪费CPU，非阻塞I/O需要轮询确认数据是否完全获取。
常用轮询技术：
- read：最原始，性能最低
- select：改进过的，根据文件描述符上的事件状态来进行判断，采用数组存储状态，有长度限制，最多1024个文件
- poll：改进select，使用链表来存储状态
- epoll： Linux下效率最高的I/O事件通知机制，进入轮询的时候如果没有I/O事件，进行休眠，直到事件将其唤醒。
- kqueue：类似epoll

#### 2.2 理想的非阻塞异步I/O
理想的非阻塞异步I/O：应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需要在I/O完成后通过信号或者回调将数据传递给应用程序。
我们常说Node是单线程的，这里的单线程是说JavaScript执行在单线程中，内部I/O任务另有线程池。
### 3. Node的异步I/O
#### 3.1 事件循环
``` plantuml
start
 if (还有事件) then (yes)
 repeat
  :取出一个事件;
  if (有关联回调) then (yes)
    :执行回调;
  endif
  repeat while (还有事件) is (yes)  
else (no)
  :退出;
endif
stop
```
进程启动的时候，Node创建一个类似while(true)的循环，每次执行循环体的过程称为Tick，每个Tick的过程就是看是否有事件等待处理，有就取出事件和相关的回调函数，如果存在关联的回调函数，就执行它们，再进入下一个循环。如果不再有事件处理，就退出进程。
#### 3.2 观察者
每个事件循环中有一个或者多个观察者，判断是否有事件需要处理的过程就是向观察者询问是否有处理的事件。事件循环就是一个典型的生产者/消费者模型。异步I/O、网络请求等是事件的生产者，为Node提供各类事件，这些事件被传递到相应的观察者那里，事件循环则从观察者那里取出事件并处理。
在Windows下这个循环基于IOCP创建，而在*nix下基于多线程创建，Node下的libuv这一层屏蔽了这些差异。
#### 3.3 请求对象
从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，叫请求对象。所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完成后的回调处理。
#### 3.4 执行回调
I/O相关操作调用完成后，将获取的结果存储在result属性上，再通知IOCP当前对象操作已经完成。在事件循环的过程中，也是用到了事件循环的I/O观察者。事件循环、观察者、请求对象和I/O线程池四者共同组成了Node异步I/O模型的基本要素。
#### 3.5 备注
在Node中，除了JavaScript是单线程的，Node自身是多线程的，只是I/O线程使用的CPU比较少。除了用户代码无法并行执行外，所有的I/O是可以并行的。
### 4. 非I/O的异步API
#### 4.1 定时器
调用setTimeOut()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时事件，如果超出就形成一个事件，回调会立即执行。定时器的问题就是，它的精度并不是完全准确的，如果某一次循环占用的时间角度，下次循环时，他或许已经超时很久了。例如setTimeOut()设定10ms后执行，但是9ms之后有一个任务占用了5ms的时间片，再次轮到定时器执行的时候，已经超时了4ms。
#### 4.2 process.nextTick()
为立即异步执行一个任务，之前使用setTimeOut(fnc,0)，这种精度不够，而且需要动用红黑树，创建定时器对象和迭代等操作，较浪费性能。process.nextTick()操作轻量。每次调用nextTick()，只会将回调函数放入队列，在下一轮Tick的时候取出执行。
#### 4.3 setImmediate()
setImmediate()与nextTick()类似，都是将回调延迟执行。从执行顺序来看是没有差别的，例如
``` javascript
process.nextTick(function(){
  console.log('延迟执行');
})
console.log('正常执行');

setImmediata(function(){
  console.log('延迟执行');
})
console.log('正常执行');
// 这两种方式执行结果一样
```
放在一起的时候，执行结果是
``` javascript
process.nextTick(function(){
  console.log('nextTick延迟执行');
})
setImmediata(function(){
  console.log('setImmediate延迟执行');
})
console.log('正常执行');
// 执行结果
// 正常执行
// nextTick延迟执行
// setImmediate延迟执行
```
原因分析：nextTick中回调函数优先级高于setImmediate()。事件循环对观察者的检查有先后顺序，process.nextTick()属于idle观察者，setImmediate()属于check观察者。每一个轮询检查中，idle观察者优先于I/O观察者，I/O观察者先于check观察者。
process.nextTick()的回调函数保存在一个数组中，setImmediate()的结果保存在链表中。行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImemediate()在每轮循环中执行链表中的一个回调函数。
### 5. 事件驱动与高性能服务器
#### 5.1 经典服务器模型
- 同步式：一次处理一个请求，其余请求等待。
- 每进程/每请求：为每个请求启动一个进程，可以处理多个请求，但是不具备扩展性
- 每线程/每请求：为每个请求启动一个线程来处理。虽然相比进程更加轻量，但是每个线程都要占用内存，当大并发请求到来时，内存会用光，服务缓慢。Apache用的是这个模式。
Node通过事件驱动的方式处理请求，无需为每个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价也很低。Nginx也是采用了事件驱动的模式。

