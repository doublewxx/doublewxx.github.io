---
title: 内存控制
date: 2021-08-22 11:17:21
tags: 
  - 内存管理
categories: Node
---
### 1. V8的垃圾回收机制与内存限制
Node中通过JavaScript使用内存是会发现只能使用部分内存，64位系统下约1.4G，32位系统下约为0.7G(不同版本的Node大小不一样)。主要因为Node是基于V8构建，V8的这套内存管理是针对浏览器的，并不是服务端。V8的垃圾回收机制有限，一次垃圾回收耗时较长，会因此JavaScript线程暂停执行的事件，应用的性能和响应能力会受限制。
#### 1.1 V8垃圾回收算法
- V8将内存分为新生代和老生代两代
- Scavenge算法将堆内存一分为二，一半使用一半空闲，每次内存垃圾回收，都是把使用中内的存活对象copy到空闲的一半里面。优点是快速，缺点是只能使用堆内存的一半，以空间换时间。对于新生代的生命周期较短的对象，比较适合。
- 当一个新生代对象经过多次复制仍然存在，则会被进行对象晋升。晋升两个条件：对象是否经历过Scavenge回收，To空间的内存占用比是否超过限制，只要满足一个就可以晋升
- 老生代内存采用Mark-Sweep和Mark-Compact结合的方式。
- Mark-Sweep分为标记和清除两个阶段。标记清除带来的问题是在一次标记清除回收后，内存不连续，此时如果要分配大对象，会出现直接触发不必要的垃圾回收。
- Mark-Compact是在对象标记死亡后，将存活的对象往一端移动，这样回收的内存就是连续的一段。
- 老生代一般使用的是标记清除，只有当内存不足以为从新生代copy过来的对象时，才会使用标记移动
- 为了避免应用逻辑与垃圾回收器看到不一样的情况，上述三种垃圾回收方法都需要暂停应用逻辑，执行完垃圾回收之后在执行，称为全停顿。
- 新生代内存对象少，全停顿问题不大，但是老生代内存大对象多，标记、清除、整理等动作就比较多。V8就把操作拆分为许多小步骤，先做初始化标记，再做清理、整理
- V8后续还引入了延迟清理和增量式整理
### 2. 高效使用内存
- 作用域链，在访问一个对象时，如果当前作用域没有，会一层一层向上寻找，直到最外层的全局作用域
- 全局作用域需要直到进程退出才能释放
- 实现外部作用域访问内部作用域中变量的方法叫做闭包，这是因为高阶函数可以将函数作为参数或返回值
### 3. 内存泄漏
- JS开发者喜欢用对象的键值来缓存东西，但是这与严格意义的缓存也有区别，缓存是有完善的过期策略，但是普通对象的键值没有