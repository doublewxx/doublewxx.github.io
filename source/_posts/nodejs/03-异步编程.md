---
title: 异步编程
date: 2021-07-11 15:25:30
tags: 
  - 异步编程
categories: Node
---
### 1. 函数式编程
 V8和异步I/O在性能上带来的提升，前后端JS编程风格一致，是Node能够迅速成功并流行起来的主要原因。
#### 1.1 高阶函数
高阶函数：可以吧函数作为参数、或者将函数作为返回值的函数。高阶函数比普通函数要灵活许多，除了通常意义上的函数调用返回外，还形成了一种后续传递风格的结果接收方式，而非单一的返回值形式。
#### 1.2 偏函数用法
偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。
### 2. 异步编程的优势与难点
多线程带来的问题：操作系统调度多线程的上下文切换开销、编程中的锁、同步问题。
#### 2.1 优势
Node带来的最大特性莫过于基于事件驱动的非阻塞I/O模型。
#### 2.2 难点
1. 异常处理：调用async方法之后，提交请求立即返回，异常并不一定发生在这个阶段，try/catch就会不起作用。因为async的callback被存放起来等到下一个事件循环(Tick)才会取出来执行。尝试对已补偿方法进行try/catch只能捕获档次事件循环内的异常，对callback抛出的异常无能为力。因此Node在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，只要为空就表明没有异常。
2. 函数嵌套过深：多个异步场景的时候，函数嵌套过深
3. 阻塞代码：js没有sleep这种线程沉睡功能，只有setInterval和setTimeOut这种函数并不能阻塞后续代码执行。如果用while去实现则会持续占用CPU进行判断
4. 多线程编程：浏览器中JS执行线程与UI渲染共用的一个线程，在Node中没有UI渲染，模型基本相同。对于服务端而言，如果服务器是多核cpu，单个Node进程实质上没有充分利用多核CPU。浏览器提出了Web Workers，通过将JS执行与UI渲染分离，更好地利用多核CPU为大量计算服务，也是一个利用消息机制合理使用多核CPU的理想模型。Web Workers可以解决利用CPU和减少阻塞UI渲染，但是不能解决UI渲染的效率问题。Node借鉴了这个模式，有了child_process和cluster模块。
5. 异步转同步：Node中试图使用同步式编程，并不能得到原生支持，只能通过库或者编译手段来实现。

### 3. 异步编程解决方案
#### 3.1 事件发布/订阅模式
1. Node自身提供的event模块是发布订阅的一个简单实现，只有addListener()、once()、on()、removeListener()、removeAllListeners()和emit()等基本的事件监听模式的方法实现。
2. 发布订阅模式常常用于解耦业务逻辑，发布者无需关注订阅的侦听器如何实现业务逻辑，数据通过消息的方式可以很灵活传递。
3. 事件侦听器模式也是一种钩子机制，利用谷子导出内部数据或状态给外部的调用者。Node中的很多对象大多具有黑盒的特点，功能点较少，如果不通过事件钩子的方式，无法获取对象在运行期间的中间值或者内部状态。
4. Node为事件发布/订阅模式做了一些额外处理，大多是为了健壮性考虑。如果一个事件添加超过10个侦听器，则会得到一条告警。可以通过emitter.setMaxListeners(0)可以去掉。这里一方面为了避免侦听器太多导致内存泄漏，另一方面是避免CPU占用过多。为了处理异常，如果触发了error事件会检查是否有侦听器监听error事件，如果有则交给事件处理，没有则会引起线程退出。
5. 实现一个继承EventEmitter的类非常简单。
6. 可以利用事件队列解决雪崩问题：雪崩问题就是在高访问量、大并发量的青黄夏缓存失效的场景，此时大量的请求同时涌入数据中，数据库无法同时承受如此大的查询请求，从而影响到网站整体的响应速度。
7. EventProxy也是一套事件订阅/发布模式的补充，可以自由订阅组合事件，是参考了Promise模式
#### 3.2 Promise/Deferred模式
1. Deferred对象是延迟对象，主要用于内部维护异步模型的状态，Promise则用于外部，通过then()方法暴露给外部以添加自定义逻辑。将业务不可变的部分封装在了Deferred中，将可变的部分交给了Promise。