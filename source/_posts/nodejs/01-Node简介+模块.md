---
title: Node简介+模块
---
### Node简介
1. Node的结构与Chrome十分相似，它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件驱动来服务IO。
2. Node的特点
- 异步I/O
- 事件与回调函数（事件的编程方式具有轻量级、松耦合、只关注事务点等有事，但是多个异步任务的场景下事件与事件相互独立，如何协作是一个问题。）
- 单线程（单线程不用在意状态的同步问题，没有死锁，也没有上下文切换带来的性能开销，但是也有无法利用多核CPU、错误会导致整个应用退出、大量计算占用CPU导致无法继续调用异步I/O。Node通过child_process子进程讲计算来利用多核CPU）
- 跨平台（基于libuv实现了跨平台）
3. Node的应用场景
- I/O密集型（面向网络且擅长并行I/O，优势在于Node利用事件循环的处理能力，而不是为每一个请求启动一个线程）。
- 是否不擅长CPU密集型任务（如果有长时间运行的计算会导致CPU时间片不能释放，后续I/O无法发起。但是只要适当调整和分解大型运算任务为多个小任务，使运算可以适时释放，不阻塞I/O调用发起）
4. Node的使用者的倚重点
- 前后端编程语言环境统一
- Node带来的高性能I/O用于实时应用
- 并行I/O使得使用者可以更高效利用分布式环境
- 并行I/O有效利用稳定借口提升Web渲染能力
- 云计算平台提供Node支持
- 工具类应用

### 模块机制
#### CommonJS规范
CommonJS规范的提出，主要为了弥补当前JS没有标准的缺陷，达到具备开发大型应用的基础能力。
模块规范
- 模块引用
```javascript
var math = require('math');
```
- 模块定义
上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，代表模块自身，exports是module的属性。
- 模块标识
模块标识就是传递给require()方法的参数，必须符合小拖放命名的字符串，或者相对路径or绝对路径。
### Node的模块实现
1. Node中引入模块，需要路径分析、文件定位、编译执行三个步骤。
2. Node中模块分为两类，一类是Node提供的模块称为核心模块。另一类是用户编写的模块，称为文件模块。
    - 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，这部分核心模块被直接加载进内存，就可以省略文件定位和编译执行步骤，路径分析中优先判断
    - 文件模块在运行时动态加载，需要三个步骤，会慢一些
3. Node对引入过的模块都会进行缓存，缓存的是编译和执行之后的对象。无论核心模块还是文件模块，都是优先采用缓存。核心模块的缓存检查先于文件模块的缓存检查。
4. 路径分析和文件定位
###### 模块标识符分析：
 - 模块加载速度：缓存模块<核心模块<路径形式的文件模块<自定义模块
###### 文件定位分析：
 - 文件扩展名分析，Node会按照.js .json .node的次序补足扩展名，依次尝试。尝试过程中，需要调用fs模块同步阻塞式地判断文件是否存在。
 - 目录分析和包：分析标识符查找到一个目录，Node会当成一个包来处理。会去查找包里面是否有package.json，取出main属性指定的文件来定位。
如果main属性指定文件名错误，会将index当做默认文件名。如果这一级目录还没有找到，会下一个模块路径进行遍历。如果所有模块路径都找不到，就跑出查找失败的异常。
###### 模块编译：
编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，根据路径载入并编译。
不同文件名载入方法有所不同
  - .js 通过fs模块同步读取文件后编译执行。
  - .node C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件
  - .json 通过fs模块同步读取文件后，用JSON.parse()解析返回结果
  - 其余扩展名，被当做js文件载入
每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能
##### JS模块的编译
在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。
```javascript
(function (exports, require, module, _filename, _dirname) { // 新增行
  var math = require('math');
  exports.area = function (radius) {
    return Math.PI * radius * radius;
  };
}); // 新增行
```
通过新增了头和尾，进行了作用域隔离，包装之后的代码会通过vm原生模块的runInThisContext()方法执行，返回一个具体的function对象。
最后把当前模块对象的exports属性、require()方法、module及在文件定位中得到的完整的文件路径和文件目录作为参数传入function()执行。
执行之后，模块的exports属性被返回给了调用方。
exports对象是通过形参的方式传入的，直接复制会改变形参的引用，但不会改变作用域外的值，因此需要用module.exports迂回一下。
##### C/C++模块的编译
Node调用process.dlopen()方法进行加载和执行。dlopen()方法在不同平台不同实现，通过libuv兼容层进行了封装。
实际上node的模块文件并不需要编译，因为已经是编译生成的，所以只有加载和执行的过程。
在执行的过程中，模块的exports对象与.node模块产生联系，然后返回给调用者。
C/C++模块执行效率快，但是入门门槛高。
##### JSON文件的编译
利用fs模块同步读取JSON文件的内容之后，调用JSON.parse()方法得到对象，在赋给模块对象的exports，供外部调用。
### 核心模块
Node核心模块在编译成可执行文件的过程中被编译进了二进制文件，核心模块分为C/C++编写和JS编写两部分，C/C++文件在项目的src目录下，JS放在lib目录下。
##### JS核心模块的编译过程
1. 转存为C/C++的代码：采用V8附带的js2c.py工具，将所有内置的JS代码转换为C++里面的数组，生产node_natives.h头文件。这个过程将JS代码以字符串的形式存储在node命名空间中，不可执行。启动Node进程的时候，JS代码直接加载进内存中。在加载过程中不用从磁盘一处处查找，直接定位会很快。
2. 编译JS核心模块：lib目录下的所有模块文件也没有定义require、module、exports这些变量。在引入JS核心模块的过程中，也经理了头尾包装的过车，才执行和导出了exports对象。与文件模块不同的是获取源码的方式和缓存执行结果的位置。核心代码源文件通过process.binding('natives')取出，编译成功的模块缓存到NativeModule._cache对象上，文件模块是缓存到Module._cache上。
##### C/C++核心模块的编译过程
核心模块包含全部由C/C++编写的和由C/C++完成核心部分，其他部分由JS实现包装或向外导出，在性能和开发速度中间平衡。
纯C/C++编写的部分统称内建模块，Node的buffer、crypto、evals、fs、os等模块都是部分通过C/C++编写的。
每一个内建模块在定义之后，都通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员。node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中，通过get_buildin_module()方法从node_module_list数组中取出这些模块。
内建模块的优势就是性能好，文件编译时被编译进二进制文件，一旦Node开始执行，被直接加载进内存，不需要定位和编译过程。
Node的所有模块类型中，文件模块可能会依赖核心模块，核心模块可能依赖内建模块。
内建模块的导出：
Node启动时生成全局变量process，并提供Binding()方法来协助加载内建模块。Binding()的实现代码在src/node.cc里面。
在加载内建模块时，先创建一个空exports对象，然后调用get_buildin_module()方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名进行换成你，返回给调用方。
### C/C++扩展模块
JS的一个典型弱点是位运算，JS中只有double型的数据类型，因此位运算要把double转为int，效率不高。
但是应用中转码、编码这些经常用到位运算，因此编写扩展模块就可以提升性能。
Node的原生模块一定程度上是可以跨平台的，但是在不同系统是用不同编译器编译为不同文件，为了看起来一致才叫.node.
扩展模块的编写与内建模块的套路一样，将方法挂载在target对象上，然后通过NODE_MODULE声明即可。
加载.node文件两个步骤：1、调用uv_dlopen()方法去打开动态链接库 2、调用ul_dlsym()方法找到动态链接库中通过NODE_MODULE宏定义的方法低值。这两个方法都是通过libuv库封装。
C++扩展模块的与JS模块的区别就是加载后不需要编译，直接执行之后就可以被外部调用，加载速度比JS模块块。
### 模块调用栈
文件模块：JS模块和C/C++扩展模块
核心模块：JS模块和C/C++内建模块
### 包与NPM
##### 包结构
```javascript
-pacakge.json // 包描述文件
-bin // 存放可执行二进制文件的目录
-lib // 存放JavaScript代码的目录
-doc // 存放文档
-test // 存放单元测试用例的代码
```
##### NPM常用功能
完成第三方模块的发布、安装和依赖
常用功能
1、查看帮助
2、安装依赖包
3、NPM钩子命令
4、发布包
5、分析包： npm ls
##### NPM潜在问题
包的质量良莠不齐
### 前后端共用模块
##### 前后端模块侧重点
前端模块的瓶颈在于带宽，后端的瓶颈在于CPU和内存
Node模块的引入过程，几乎是全同步的，但是并不适应前端，最后AMD规范和CMD规范这种异步规范胜出
##### AMD规范
AMD规范是CommonJS模块规范的一个延伸，模块定义为
```javascript
define(id?, dependencies?, factory)
```
AMD需要用define来明确定义一个模块，在Node中是隐式包装的，都是为了作用域隔离。
##### CMD规范
CMD由玉伯提出，去呗在于定义模块和依赖引入的部分
AMD需要在定义的时候指定所有的依赖，而CMD的依赖支持动态引入
```javascript
define(factory)
```